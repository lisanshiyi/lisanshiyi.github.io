(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{331:function(s,n,a){"use strict";a.r(n);var t=a(7),e=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("blockquote",[n("p",[s._v("全局解释器锁GIL(Global Interpreter Lock)")])]),s._v(" "),n("h2",{attrs:{id:"一、gil理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、gil理解"}},[s._v("#")]),s._v(" 一、GIL理解")]),s._v(" "),n("ul",[n("li",[s._v("GIL指定同时只允许一个线程控制Python解释器。")]),s._v(" "),n("li",[s._v("GIL是CPU限制型和多线程代码中的性能瓶颈。")]),s._v(" "),n("li",[s._v("GIL导致Python多线程属于伪并发的多线程。")]),s._v(" "),n("li",[s._v("GIL只在CPython解释器上存在。")])]),s._v(" "),n("h3",{attrs:{id:"gil的影响"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gil的影响"}},[s._v("#")]),s._v(" GIL的影响")]),s._v(" "),n("ul",[n("li",[s._v("Python中同一时刻有且只有一个线程会执行；")]),s._v(" "),n("li",[s._v("Python中的多个线程由于GIL锁的存在无法利用多核CPU；")]),s._v(" "),n("li",[s._v("Python中的多线程不适合计算机密集型的程序；")]),s._v(" "),n("li",[s._v("问题：GIL的存在使程序无法充分利用CPU进行运算，那么它真的一无是处么？\n"),n("ul",[n("li",[s._v("计算密集型程序【比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力】")]),s._v(" "),n("li",[s._v("IO密集型程序【比如网络数据的收发，大文件的读写，这样的程序称为IO密集型程序】")])])])]),s._v(" "),n("h3",{attrs:{id:"为什么选择gil作为解决方案呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么选择gil作为解决方案呢"}},[s._v("#")]),s._v(" 为什么选择GIL作为解决方案呢？")]),s._v(" "),n("ul",[n("li",[s._v("内核CPython会大量使用C语言库，但大部分C语言库都不是原生线程安全的(线程安全会降低性能和增加复杂度)")]),s._v(" "),n("li",[s._v("早期实用解决方案，解决CPython开发人员在Python生命中早期面临的一个线程安全难题。")]),s._v(" "),n("li",[s._v("后期由于Python内核基于C语言编写，所以开发人员为Python需要的功能编写许多C库扩展。为了防止不一致的更改，继续延用GIL")])]),s._v(" "),n("h3",{attrs:{id:"为什么还没有删除gil"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么还没有删除gil"}},[s._v("#")]),s._v(" 为什么还没有删除GIL？")]),s._v(" "),n("ul",[n("li",[s._v("Python的开发人员对此有很多抱怨，但是Python这样流行的语言删除GIL，向下兼容代价太大了")]),s._v(" "),n("li",[s._v("Py3社区也尝试过执行此操作，不过导致性能下降又加上了（破坏了现有的C扩展，这些扩展依赖于GIL，需要程序维护多线程，相对性能下降）")]),s._v(" "),n("li",[s._v("Py3社区GIL重大改进：\n"),n("ul",[n("li",[s._v("计算密集和I/O密集共存的程序中，GIL致使I/O密集的线程饿死，因为没有机会从CPU绑定的线程中获取GIL。所以Python内置了一种机制，强制线程在固定间隔后释放GIL，并且如果没有其他人获得GIL，则相同的线程才可以继续使用它。")]),s._v(" "),n("li",[s._v("这种机制的依然存在问题大多数情况下，CPU密集型线程会在其他线程获取GIL之前重新获取GIL。具体如下"),n("a",{attrs:{href:"https://juejin.cn/post/6932355242721804296",target:"_blank",rel:"noopener noreferrer"}},[s._v("可视化"),n("OutboundLink")],1),s._v("。")]),s._v(" "),n("li",[s._v("Python3.2中社区添加了一种机制，可以在其他线程有机会运行之前不允许当前线程重新获取GIL。")])])])]),s._v(" "),n("h2",{attrs:{id:"二、gil原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、gil原理"}},[s._v("#")]),s._v(" 二、GIL原理")]),s._v(" "),n("h3",{attrs:{id:"gil如何工作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gil如何工作"}},[s._v("#")]),s._v(" GIL如何工作")]),s._v(" "),n("ul",[n("li",[s._v("下图就是一个GIL在Python程序中的工作示例。")]),s._v(" "),n("li",[s._v("其中，线程1、2、3轮流执行，每一个线程在执行是，都会锁住GIL，以阻止别的线程执行；")]),s._v(" "),n("li",[s._v("同样的，每一个线程执行一段后，会释放GIL，以允许别的线程开始利用资源。")])]),s._v(" "),n("p",[n("img",{staticClass:"lazy",attrs:{alt:"img","data-src":"https://lisanshiyi.com/assets/language/python/GIL_1.png",loading:"lazy"}})]),s._v(" "),n("ul",[n("li",[s._v("由于古老GIL机制，如果线程2需要在CPU2上执行，它需要先等待在CPU1上执行的线程1释放GIL（记住：GIL是全局的）")]),s._v(" "),n("li",[s._v("如果线程1是因为 i/o 阻塞让出的GIL，那么线程2必定拿到GIL。但如果线程1是因为timer ticks计数满100ticks(大概对应了1000个bytecodes)让出GIL，那么这个时候线程1和线程2公平竞争。")]),s._v(" "),n("li",[s._v("但要命的是，在Python 2.x, 线程1不会动态的调整自身的优先级，所以很大概率下次被选中执行的还是线程1，在很多个这样的选举周期内，线程2只能安静的看着线程1拿着GIL在CPU 1上欢快的执行。")]),s._v(" "),n("li",[s._v("极端一点的情况下，比如线程1使用了while True在CPU1上执行，那就真是“一核有难，八核围观”了，如下图所示：")])]),s._v(" "),n("p",[n("img",{staticClass:"lazy",attrs:{alt:"img","data-src":"https://lisanshiyi.com/assets/language/python/GIL_2.png",loading:"lazy"}})]),s._v(" "),n("ul",[n("li",[s._v("整体来说，每一个Python的线程都是类似这样循环的封装，我们可以看看下面的代码")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("for(;;){\n    if(--ticker < 0)\n    /*Give another thread a chance*/\n    PyThread_release_lock(interpreter_lock);\n \n    /*Other threads may run now*/\n \n    PyThread_acquire_lock(interpreter_lock,1);\n}\n \nbytecode = *next_instr++\nswitch (bytecode){\n    /*execute the next instruction...*/\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("ul",[n("li",[s._v("从上面的代码可以看出来，每个Python线程都会先检查ticker计数。只有ticker大于0的时候，线程才会去执行自己的bytecode。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("python -c 'import sys;print sys.getcheckinterval()'\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("h3",{attrs:{id:"gil结构体"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gil结构体"}},[s._v("#")]),s._v(" GIL结构体")]),s._v(" "),n("ul",[n("li",[s._v("以下结构体就是GIL的定义")]),s._v(" "),n("li",[s._v("locked用来指示是否上锁, 1表示已有线程上锁, 0表示锁空闲，")]),s._v(" "),n("li",[s._v("lock_released和mutex来同步对locked的访问。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("typedef struct {\n    char \tlocked; /* 0=unlocked, 1=locked */\n    /* a <cond, mutex> pair to handle an acquire of a locked lock */\n    pthread_cond_t \tlock_released;\n    pthread_mutex_t \tmut;\n} pthread_lock;\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("h3",{attrs:{id:"gil的获取与释放"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gil的获取与释放"}},[s._v("#")]),s._v(" GIL的获取与释放")]),s._v(" "),n("ul",[n("li",[s._v("线程对GIL的操作本质上就是通过修改locked状态变量来获取或释放GIL。所以主要的操作有两个:")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("PyThread_acquire_lock()\nPyThread_release_lock()\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("ul",[n("li",[s._v("以下是获取GIL的实现，可以看到，线程在其他线程已经获取GIL的时候，需要通过pthread_cond_wait()等待获取GIL的线程释放GIL。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/*获取GIL*/\nint  PyThread_acquire_lock(PyThread_type_lock lock, int waitflag) \n{\n    int success;\n    pthread_lock *thelock = (pthread_lock *)lock;\n    int status, error = 0;\n    status = pthread_mutex_lock( &thelock->mut ); /*先获取mutex, 获得操作locked变量的权限*/\n    success = thelock->locked == 0;\n    if ( !success && waitflag ) { /*已有线程上锁,*/\n        while ( thelock->locked ) {\n            /*通过pthread_cond_wait等待持有锁的线程释放锁*/\n            status = pthread_cond_wait(&thelock->lock_released,\n                                       &thelock->mut);\n        }\n        success = 1;\n    }\n    if (success) thelock->locked = 1; /*当前线程上锁*/\n    status = pthread_mutex_unlock( &thelock->mut ); /*解锁mutex, 让其他线程有机会进入临界区等待上锁*/\n    if (error) success = 0;\n    return success; \n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br")])]),n("ul",[n("li",[s._v("以下是释放GIL的过程,特别注意最后一步, 通过pthread_cond_signal()通知其他等待(pthread_cond_wait())释放GIL的线程,让这些线程可以获取GIL。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/*释放GIL*/\nvoid PyThread_release_lock(PyThread_type_lock lock)\n{\n    pthread_lock *thelock = (pthread_lock *)lock;\n    int status, error = 0;\n    status = pthread_mutex_lock( &thelock->mut ); /*通过mutex获取操作locked变量的权限*/\n    thelock->locked = 0; /*实际的释放GIL的操作, 就是将locked置为0*/\n    status = pthread_mutex_unlock( &thelock->mut ); /*解锁mutex*/\n    status = pthread_cond_signal( &thelock->lock_released ); /*这步非常关键, 通知其他线程当前线程已经释放GIL*/\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("h2",{attrs:{id:"三、gil调优"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、gil调优"}},[s._v("#")]),s._v(" 三、GIL调优")]),s._v(" "),n("ul",[n("li",[s._v("给线程加锁，会对python多线程的效率有不小的影响，使用多线程进行CPU密集型的操作，会存在频繁的上下文切换，效率低下")])]),s._v(" "),n("h3",{attrs:{id:"不要用c语言版本的python解释器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不要用c语言版本的python解释器"}},[s._v("#")]),s._v(" 不要用C语言版本的Python解释器")]),s._v(" "),n("ul",[n("li",[s._v("Python有多个解释器实现，包括C，Java，C＃和Python编写的CPython，Jython，IronPython和PyPy是最受欢迎的，GIL仅存在于CPython的原始Python实现中")])]),s._v(" "),n("h3",{attrs:{id:"让子线程运行其他语言代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#让子线程运行其他语言代码"}},[s._v("#")]),s._v(" 让子线程运行其他语言代码")]),s._v(" "),n("ul",[n("li",[s._v("主线程运行Python代码，子线程运行C语言代码(C语言的动态库)")]),s._v(" "),n("li",[s._v("CPython的优势就是与C模块的结合，因此可以借助Ctypes调用C的动态库来实现将计算转移，C动态库没有GIL可以实现对多核的利用。")]),s._v(" "),n("li",[s._v("深度算法 rcnn")])]),s._v(" "),n("h3",{attrs:{id:"多进程代替多线程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多进程代替多线程"}},[s._v("#")]),s._v(" 多进程代替多线程")]),s._v(" "),n("ul",[n("li",[s._v("多进程可以利用多核CPU")]),s._v(" "),n("li",[s._v("通过使用多进程，我们并行运行了一定数量的python解释器，每一个进程都有私有的空间，有自己的GIL，并且每一个都串行运行，所以没有GIL之间的竞争")]),s._v(" "),n("li",[s._v("因此GIL不会成为问题。Python有一个multiprocessing模块，可以让我们像这样轻松地创建流程：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("import time\nfrom multiprocessing import Pool\nCOUNT = 10000000\nstart = time.clock()\ndef countdown(n):\n    while n > 0:\n        n -= 1\n\npool = Pool(processes=2)\nstart = time.clock()\nr1 = pool.apply_async(countdown, [COUNT//2])\nr2 = pool.apply_async(countdown, [COUNT//2])\npool.close()\npool.join()\nprint('Time used:', time.clock() - start)\n# ('Time used:', 0.0017779999999998353)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])]),n("ul",[n("li",[s._v("时间没有下降到我们上面看到的一半，因为进程管理有自己的开销。多个进程比多个线程重，因此请记住，这可能会成为一个扩展瓶颈。")])]),s._v(" "),n("h3",{attrs:{id:"协程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[s._v("#")]),s._v(" 协程")]),s._v(" "),n("ul",[n("li",[s._v("在Python3.4之前，官方没有对协程的支持，存在一些三方库的实现，比如gevent和Tornado")]),s._v(" "),n("li",[s._v("3.4之后就内置了asyncio标准库，官方真正实现了协程这一特性。")]),s._v(" "),n("li",[s._v("在IO密集型的情况下，使用协程能提高最高效率")]),s._v(" "),n("li",[s._v("注意；协程不是任何单位，只是一个程序员YY出来的东西")]),s._v(" "),n("li",[s._v("协程的目的：手动实现“遇到IO切换 + 保存状态” 去欺骗操作系统，让操作系统误以为没有IO操作，将CPU的执行权限给你，从而单线程下实现并发")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("import time\n#遇到IO切换（gevent） + 保存状态\nfrom gevent import monkey  #猴子补丁\nmonkey.patch_all()  #监听所有的任务是否有IO操作\nfrom gevent import spawn  #spawn(任务)\nfrom gevent import joinall\n\nCOUNT = 10000000\nstart = time.clock()\ndef countdown(n):\n    while n > 0:\n        n -= 1\n\nsp1 = spawn(countdown, COUNT//2)\nsp2 = spawn(countdown, COUNT//2)\n\n# sp1.start()\n# sp2.start()\n# sp1.join()\n# sp2.join()\njoinall([sp1, sp2])  #等同于上面六步\n\nprint('Time used:', time.clock() - start)\n# ('Time used:', 0.40398999999999985)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br")])]),n("h3",{attrs:{id:"问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[s._v("#")]),s._v(" 问题")]),s._v(" "),n("ul",[n("li",[s._v("多进程利用多核优势，怎样发挥单核优势呢")]),s._v(" "),n("li",[s._v("Python社区中一些人从CPython中删除GIL(eg："),n("a",{attrs:{href:"https://pythoncapi.readthedocs.io/gilectomy.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("Gilectomy"),n("OutboundLink")],1),s._v(")")])]),s._v(" "),n("h2",{attrs:{id:"四、速度测试"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、速度测试"}},[s._v("#")]),s._v(" 四、速度测试")]),s._v(" "),n("ul",[n("li",[s._v("测评结果")])]),s._v(" "),n("table",[n("thead",[n("tr",[n("th",[s._v("测试方式")]),s._v(" "),n("th",[s._v("测试时间")])])]),s._v(" "),n("tbody",[n("tr",[n("td",[s._v("单线程")]),s._v(" "),n("td",[s._v("0.392953")])]),s._v(" "),n("tr",[n("td",[s._v("多线程")]),s._v(" "),n("td",[s._v("0.910045")])]),s._v(" "),n("tr",[n("td",[s._v("多进程")]),s._v(" "),n("td",[s._v("0.0017779999999998353")])]),s._v(" "),n("tr",[n("td",[s._v("协程")]),s._v(" "),n("td",[s._v("0.40398999999999985")])])])]),s._v(" "),n("ul",[n("li",[s._v("测试代码：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("# -*- coding: utf-8 -*-\nimport time\nCOUNT = 10000000\nstart = time.clock()\ndef countdown(n):\n    while n > 0:\n        n -= 1\ncountdown(COUNT)\nprint(\"Time used:\",(time.clock() - start))\n# ('Time used:', 0.392953)\n\nimport time\nfrom threading import Thread\nCOUNT = 10000000\nstart = time.clock()\ndef countdown(n):\n    while n > 0:\n        n -= 1\nt1 = Thread(target=countdown, args=[COUNT // 2])\nt2 = Thread(target=countdown, args=[COUNT // 2])\nt1.start()\nt2.start()\nt1.join()\nt2.join()\nprint(\"Time used:\",(time.clock() - start))\n# ('Time used:', 0.910045)\n\nimport time\nfrom multiprocessing import Pool\nCOUNT = 10000000\nstart = time.clock()\ndef countdown(n):\n    while n > 0:\n        n -= 1\npool = Pool(processes=2)\nstart = time.clock()\nr1 = pool.apply_async(countdown, [COUNT//2])\nr2 = pool.apply_async(countdown, [COUNT//2])\npool.close()\npool.join()\nprint('Time used:', time.clock() - start)\n# ('Time used:', 0.0017779999999998353)\n\nimport time\n#遇到IO切换（gevent） + 保存状态\nfrom gevent import monkey  #猴子补丁\nmonkey.patch_all()  #监听所有的任务是否有IO操作\nfrom gevent import spawn  #spawn(任务)\nfrom gevent import joinall\nCOUNT = 10000000\nstart = time.clock()\ndef countdown(n):\n    while n > 0:\n        n -= 1\nsp1 = spawn(countdown, COUNT//2)\nsp2 = spawn(countdown, COUNT//2)\n# sp1.start()\n# sp2.start()\n# sp1.join()\n# sp2.join()\njoinall([sp1, sp2])  #等同于上面六步\nprint('Time used:', time.clock() - start)\n# ('Time used:', 0.40398999999999985)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br"),n("span",{staticClass:"line-number"},[s._v("55")]),n("br"),n("span",{staticClass:"line-number"},[s._v("56")]),n("br"),n("span",{staticClass:"line-number"},[s._v("57")]),n("br"),n("span",{staticClass:"line-number"},[s._v("58")]),n("br"),n("span",{staticClass:"line-number"},[s._v("59")]),n("br"),n("span",{staticClass:"line-number"},[s._v("60")]),n("br"),n("span",{staticClass:"line-number"},[s._v("61")]),n("br"),n("span",{staticClass:"line-number"},[s._v("62")]),n("br"),n("span",{staticClass:"line-number"},[s._v("63")]),n("br")])]),n("h2",{attrs:{id:"五、扩展"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#五、扩展"}},[s._v("#")]),s._v(" 五、扩展")]),s._v(" "),n("h3",{attrs:{id:"什么时候会释放gil锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么时候会释放gil锁"}},[s._v("#")]),s._v(" 什么时候会释放GIL锁")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("- 遇到像i/o操作，这种会有时间空闲情况 造成cpu闲置的情况会释放GIL\n- 会有一个专门ticks进行计数，一旦ticks数值达到100这个时候释放GIL锁，线程之间开始竞争GIL锁(说明:ticks这个数值可以进行设置来延长或者缩减获得GIL锁的线程使用cpu的时间)\n")])])]),n("h3",{attrs:{id:"互斥锁和gil锁的关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁和gil锁的关系"}},[s._v("#")]),s._v(" 互斥锁和GIL锁的关系")]),s._v(" "),n("ul",[n("li",[s._v("GIL锁\n"),n("ul",[n("li",[s._v("GIL是Python解释层面的锁，解决解释器中多个线程的竞争资源问题")]),s._v(" "),n("li",[s._v("保证同一时刻只有一个线程能使用到cpu")]),s._v(" "),n("li",[s._v("语言层面本身维护锁机制用来保证线程安全")])])]),s._v(" "),n("li",[s._v("互斥锁\n"),n("ul",[n("li",[s._v("线程互斥锁是Python代码层面的锁，解决Python程序中多线程共享资源的问题")]),s._v(" "),n("li",[s._v("多线程时，保证修改共享数据时有序的修改")]),s._v(" "),n("li",[s._v("不会产生数据修改混乱，线程锁，程序员需要自行加／解锁来保证线程安全;")])])]),s._v(" "),n("li",[s._v("案例：假设只有一个进程，这个进程中有两个线程 Thread1，Thread2，要修改共享的数据date，并且有互斥锁:")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\t1. 多线程运行，假设Thread1获得GIL可以使用cpu，这时Thread1获得互斥锁lock，Thread1可以改date数据(但并没有开始修改数据);\n\t2. Thread1线程在修改date数据前发生了i/o操作或者ticks计数满100((注意就是没有运行到修改data数据),这个时候 Thread1 让出了TIL，GIL锁可以被竞争);\n\t3. Thread1和Thread2开始竞争GIL(注意:如果Thread1是因为i/o阻塞让出的GIL，Thread2必定拿到GIL,如果Thread1是因为ticks计数满100让出GIL这个时候Thread1和Thread2公平竞争);\n\t4. 假设Thread2正好获得了GIL, 运行代码去修改共享数据date，由于Thread1有互斥锁lock，所以Thread2无法更改共享数据date,这时Thread2让出GIL锁, GIL锁再次发生竞争;\n\t5. 假设Thread1又抢到GIL，由于其有互斥锁Lock所以其可以继续修改共享数据data,当Thread1修改完数据释放互斥锁lock，Thread2在获得GIL与lock后才可对data进行修改\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("h2",{attrs:{id:"参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),n("ul",[n("li",[s._v("C互斥锁、信号量：https://www.cnblogs.com/luzhiyuan/p/4380793.html")]),s._v(" "),n("li",[s._v("理解GIL：https://www.youtube.com/watch?v=Obt-vMVdM8s&feature=youtu.be")])])])}),[],!1,null,null,null);n.default=e.exports}}]);